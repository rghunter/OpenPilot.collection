diff -ur others/gspcav1-20071224/gspca_core.c gspcav1-20071224-kb1/gspca_core.c
--- others/gspcav1-20071224/gspca_core.c	2007-12-24 17:56:47.000000000 +0100
+++ gspcav1-20071224-kb1/gspca_core.c	2008-02-13 17:44:02.000000000 +0100
@@ -79,6 +79,10 @@
 * NOTE: This should be changed to 0, 1, or 2 for production kernels
 */
 static int debug = 0;
+/* Use Nicolas Boichat - K-Team dirty skip for ARM-based system */
+/* It helps a lot to get better frame rate at high resolution, I don't
+ * know precisely why... */
+static int dirty_skip = 1;
 /* Force image to be read in RGB instead of BGR. This option allow
 * programs that expect RGB data (e.g. gqcam) to work with this driver. */
 static int force_rgb = 0;
@@ -107,6 +111,7 @@
 static int force_gamma_id=-1;
 module_param(autoexpo, int, 0644);
 module_param(debug, int, 0644);
+module_param(dirty_skip, int, 0644);
 module_param(force_rgb, int, 0644);
 module_param(gamma, int, 0644);
 module_param(OffRed, int, 0644);
@@ -860,8 +865,12 @@
 #include "Pixart/pac207.h"
 #include "Pixart/pac7311.h"
 #include "Vimicro/vc032x.h"
-/* function for the tasklet */
-void outpict_do_tasklet(unsigned long ptr);
+
+struct workqueue_struct* gspca_workqueue;
+
+/* function for the workqueue */
+void outpict_do_work(struct work_struct* ptr);
+
 /**********************************************************************
 *
 * Memory management
@@ -1062,10 +1071,11 @@
 			spca50x->frame[n].grabstate = FRAME_UNUSED;
 			spca50x->frame[n].scanstate = STATE_SCANNING;
 		}
-/* start the cam and initialize the tasklet lock */
+/* start the cam and initialize the workqueue lock */
 		spca50x->funct.start(spca50x);
 		spca50x->streaming = 1;
 		atomic_set(&spca50x->in_use, 0);
+		atomic_set(&spca50x->dirty_skip, 0);
 		PDEBUG(3, "Submit URB Now");
 /* Submit the URBs. */
 		for (n = 0; n < SPCA50X_NUMSBUF; ++n) {
@@ -1528,10 +1538,12 @@
 		   *spca50x, unsigned char *cdata)
 {
 	struct spca50x_frame *frame = NULL;
-	PDEBUG(2, "Frame %d State %d", spca50x->curframe,
-	       spca50x->frame[spca50x->curframe].grabstate);
-	if (spca50x->frame[spca50x->curframe].grabstate != FRAME_ERROR)
-		spca50x->curframe = (spca50x->curframe + 1) % SPCA50X_NUMFRAMES;
+	int nextframe = (spca50x->curframe + 1) % SPCA50X_NUMFRAMES;
+	PDEBUG(2, "NEXT Frame %d State %x (in_use=%d, nextframe=%d, nextframestate=%d, workframe=%d)", spca50x->curframe,
+	       spca50x->frame[spca50x->curframe].grabstate, atomic_read(&spca50x->in_use),
+		nextframe, spca50x->frame[nextframe].grabstate, spca50x->workframe);
+	if ((spca50x->frame[spca50x->curframe].grabstate != FRAME_ERROR) && (spca50x->workframe != nextframe))
+		spca50x->curframe = nextframe;
 	frame = &spca50x->frame[spca50x->curframe];
 	if (spca50x->pictsetting.change) {
 		memcpy(&frame->pictsetting, &spca50x->pictsetting,
@@ -1551,28 +1563,32 @@
 	return frame;
 }
 
-/* Tasklet function to decode */
+/* Work function to decode */
+/* We need a workqueue, not a tasklet, as we WANT our code to be interruptible */
 void
-outpict_do_tasklet(unsigned long ptr)
+outpict_do_work(struct work_struct *work)
 {
 	int err;
-	struct spca50x_frame *taskletframe = (struct spca50x_frame *) ptr;
-	taskletframe->scanlength = taskletframe->highwater - taskletframe->data;
+
+	struct usb_spca50x* spca50x_dev = container_of(work, struct usb_spca50x, work);
+	struct spca50x_frame *workframe = &spca50x_dev->frame[spca50x_dev->workframe];
+	workframe->scanlength = workframe->highwater - workframe->data;
 	PDEBUG(2,
-	       "Tasklet ask spcadecoder hdrwidth %d hdrheight %d method %d ",
-	       taskletframe->hdrwidth, taskletframe->hdrheight,
-	       taskletframe->method);
-	if ((err = spca50x_outpicture(taskletframe)) < 0) {
-		PDEBUG(2, "frame decoder failed (%d)", err);
-		taskletframe->grabstate = FRAME_ERROR;
+	       "Work ask spcadecoder ptr %p hdrwidth %d hdrheight %d method %d ",
+	       workframe, workframe->hdrwidth, workframe->hdrheight,
+	       workframe->method);
+	if ((err = spca50x_outpicture(workframe)) < 0) {
+		PDEBUG(-1, "frame decoder failed (%d)", err);
+		workframe->grabstate = FRAME_ERROR;
 	} else {
-		taskletframe->grabstate = FRAME_DONE;
+		workframe->grabstate = FRAME_DONE;
 		PDEBUG(2, "Decode framestate return %d",
-		       taskletframe->grabstate);
+		       workframe->grabstate);
 	}
-	if (waitqueue_active(&taskletframe->wq))
-		wake_up_interruptible(&taskletframe->wq);
-	atomic_set(&taskletframe->spca50x_dev->in_use, 0);
+	if (waitqueue_active(&workframe->wq))
+		wake_up_interruptible(&workframe->wq);
+	PDEBUG(2, "Decoding done! workframe=%p", workframe);
+	atomic_set(&spca50x_dev->in_use, 0);
 }
 
 /*********************************************************************
@@ -1618,8 +1634,11 @@
 			spca50x->synchro = 0;
 			continue;
 		}
-		PDEBUG(5, "Packet data [%d,%d,%d] Status: %d", datalength, st,
-		       urb->iso_frame_desc[i].offset, st);
+		PDEBUG(2, "Packet data [%d,%d,%d] Status: %d in_use: %d", datalength, st,
+		       urb->iso_frame_desc[i].offset, st, atomic_read(&spca50x->in_use));
+		if (dirty_skip && atomic_read(&spca50x->in_use)) {
+			atomic_set(&spca50x->dirty_skip, 1);
+		}
 		frame = &spca50x->frame[spca50x->curframe];
 		if (frame->last_packet == -1) {
 /*initialize a new frame */
@@ -1634,12 +1653,12 @@
 					       &datalength)) < 0)
 			continue;
 		sequenceNumber = sof;
-		PDEBUG(3, "spca50x: Packet seqnum = 0x%02x.  curframe=%2d",
+		PDEBUG(2, "spca50x: Packet seqnum = 0x%02x.  curframe=%2d",
 		       sequenceNumber, spca50x->curframe);
 		pData = cdata;
 /* Can we find a frame start */
 		if (sequenceNumber == 0) {
-			PDEBUG(3, "spca50x: Found Frame Start!, framenum = %d",
+			PDEBUG(2, "spca50x: Found Frame Start!, framenum = %d",
 			       spca50x->curframe);
 // Start of frame is implicit end of previous frame
 // Check for a previous frame and finish it off if one exists
@@ -1665,19 +1684,22 @@
 /* Decode the frame one at a times or drop*/
 						if (!atomic_read
 						    (&spca50x->in_use)) {
-							atomic_set(&spca50x->
-								   in_use, 1);
-							spca50x->
-							    spca5xx_tasklet.
-							    data =
-							    (unsigned long)
-							    frame;
-							tasklet_schedule
-							    (&spca50x->
-							     spca5xx_tasklet);
-						} else
-							frame->grabstate =
-							    FRAME_ERROR;
+							if (!atomic_read(&spca50x->dirty_skip)) {
+								PDEBUG(2, "Scheduling frame=%p...", frame);
+								atomic_set(&spca50x->
+									   in_use, 1);
+								spca50x->workframe = spca50x->curframe;
+								queue_work(gspca_workqueue, &spca50x->work);
+							}
+							else {
+								PDEBUG(2, "Dropping dirty frame...");
+								atomic_set(&spca50x->
+									   dirty_skip, 0);
+								frame->grabstate = FRAME_ERROR;
+							}
+						} else {
+							PDEBUG(2, "Had data, but had to drop it... (work=%d, cur=%d)", spca50x->workframe, spca50x->curframe);
+						}
 					} else
 						frame->grabstate = FRAME_ERROR;
 				} else {
@@ -1695,15 +1717,18 @@
 				frame->scanstate = STATE_LINES;
 		}
 /* Are we in a frame? */
-		if (frame == NULL || frame->scanstate != STATE_LINES)
+		if (frame == NULL || frame->scanstate != STATE_LINES) {
+			PDEBUG(2, "Woooops, not in frame...");
 			continue;
+		}
 		frame->last_packet = sequenceNumber;
 		pData = cdata + iPix;	// Skip packet header (1 or 10 bytes)
 // Consume data
-		PDEBUG(5, "Processing packet seq  %d,length %d,totlength %d",
+		PDEBUG(2, "Processing packet seq  %d,length %d,totlength %d",
 		       frame->last_packet, datalength, frame->totlength);
 /* this copy consume input data from the isoc stream */
 		if ((datalength > 0)) {
+			PDEBUG(2, "Copying data to %p (%d)...", frame->highwater, datalength);
 			memcpy(frame->highwater, pData, datalength);
 			frame->highwater += datalength;
 			frame->totlength += datalength;
@@ -2034,6 +2059,7 @@
 	if (spca50x->present) {
 		spca50x_stop_isoc(spca50x);
 		spcaCameraShutDown(spca50x);
+		cancel_work_sync(&spca50x->work);
 		for (i = 0; i < SPCA50X_NUMFRAMES; i++) {
 			if (waitqueue_active(&spca50x->frame[i].wq))
 				wake_up_interruptible(&spca50x->frame[i].wq);
@@ -2349,7 +2375,7 @@
 		{
 			int ret;
 			unsigned int frame = *((unsigned int *) arg);
-			PDEBUG(4, "syncing to frame %d, grabstate = %d", frame,
+			PDEBUG(2, "syncing to frame %d, grabstate = %d", frame,
 			       spca50x->frame[frame].grabstate);
 			switch (spca50x->frame[frame].grabstate) {
 			case FRAME_UNUSED:
@@ -2372,7 +2398,7 @@
 				if (ret)
 					return -EINTR;
 // ?????
-				PDEBUG(4,
+				PDEBUG(2,
 				       "Synch Ready on frame %d, grabstate = %d",
 				       frame, spca50x->frame[frame].grabstate);
 				if (spca50x->frame[frame].grabstate ==
@@ -2390,7 +2416,7 @@
 * Can this be avoided somehow?
 */
 				spca50x->frame[frame].grabstate = FRAME_UNUSED;
-				PDEBUG(4, "Release frame %d state %d\n", frame,
+				PDEBUG(2, "Release frame %d state %d\n", frame,
 				       spca50x->frame[frame].grabstate);
 				break;
 			}	/* end switch */
@@ -4316,8 +4342,7 @@
 	usb_set_intfdata(intf, spca50x);
 	if (spca50x_create_sysfs(spca50x->vdev))
 		goto error;
-	tasklet_init(&spca50x->spca5xx_tasklet,
-		     outpict_do_tasklet, (unsigned long) 0);
+	INIT_WORK(&spca50x->work, &outpict_do_work);
 	return 0;
       error:
 	if (spca50x->vdev) {
@@ -4391,6 +4416,7 @@
 static int __init
 usb_spca5xx_init(void)
 {
+	gspca_workqueue = create_singlethread_workqueue("gspca");
 	if (usb_register(&spca5xx_driver) < 0)
 		return -1;
 	info("gspca driver %s registered", gspca_version);
@@ -4400,6 +4426,7 @@
 usb_spca5xx_exit(void)
 {
 	usb_deregister(&spca5xx_driver);
+	destroy_workqueue(gspca_workqueue);
 	info("driver gspca deregistered");
 }
 
diff -ur others/gspcav1-20071224/gspca.h gspcav1-20071224-kb1/gspca.h
--- others/gspcav1-20071224/gspca.h	2007-12-24 17:56:47.000000000 +0100
+++ gspcav1-20071224-kb1/gspca.h	2008-02-13 17:33:08.000000000 +0100
@@ -33,7 +33,7 @@
 #define SPCA50X_ENDPOINT_ADDRESS 1	/* Isoc endpoint number */
 #define PAC207_ENDPOINT_ADDRESS 5	/* Isoc endpoint number */
 /* only 2 or 4 frames are allowed here !!! */
-#define SPCA50X_NUMFRAMES 2
+#define SPCA50X_NUMFRAMES 4
 #define SPCA50X_NUMSBUF 4	/* 2 is problematic on some systems */
 
 #define VENDOR_SONIX 0x0c45
@@ -388,8 +388,9 @@
 struct usb_spca50x {
 	struct video_device *vdev;
 	struct usb_device *dev;	/* Device structure */
-	struct tasklet_struct spca5xx_tasklet;	/* use a tasklet per device */
+	struct work_struct work;	/* use a work struct per device */
 	atomic_t in_use; /*tasklet list protect */
+	atomic_t dirty_skip; /* Prevent from using the same data over and over again */
 	struct dec_data maindecode;
 	unsigned long last_times;	//timestamp
 	unsigned int dtimes;	//nexttimes to acquire
@@ -444,6 +445,7 @@
 	int compress;		/* Should the next frame be compressed? */
 	char *fbuf;		/* Videodev buffer area */
 	int curframe;		/* Current receiving frame buffer */
+	int workframe;		/* Frame to be processed by the work (decoding) */
 	struct spca50x_frame frame[SPCA50X_NUMFRAMES];
 	struct spca50x_sbuf sbuf[SPCA50X_NUMSBUF];
 /* Temporary jpeg decoder workspace */
diff -ur others/gspcav1-20071224/Makefile gspcav1-20071224-kb1/Makefile
--- others/gspcav1-20071224/Makefile	2007-12-24 18:03:38.000000000 +0100
+++ gspcav1-20071224-kb1/Makefile	2008-02-13 12:06:19.000000000 +0100
@@ -34,11 +34,11 @@
 
 else   # We were called from command line
 
-KERNEL_VERSION = `uname -r`
-KERNELDIR := /lib/modules/$(KERNEL_VERSION)/build
+KERNELDIR = ${KTEAM_KERNEL_HOME}
+INSTALLDIR = ${KTEAM_HOME}/dist/lib/modules/${KTEAM_KERNEL_VERSION}
 PWD  := $(shell pwd)
-MODULE_INSTALLDIR = /lib/modules/$(KERNEL_VERSION)/kernel/drivers/usb/media/
-MODULE_INSTALLDIR2 = /lib/modules/$(KERNEL_VERSION)/kernel/drivers/media/video/
+MODULE_INSTALLDIR = $(INSTALLDIR)/kernel/drivers/usb/media/
+MODULE_INSTALLDIR2 = $(INSTALLDIR)/kernel/drivers/media/video/
 
 default:
 	$(MAKE) -C $(KERNELDIR) SUBDIRS=$(PWD) CC=$(CC) modules
@@ -48,11 +48,9 @@
 	rm -f $(MODULE_INSTALLDIR)spca5xx.ko
 	rm -f $(MODULE_INSTALLDIR2)gspca.ko
 	install -c -m 0644 gspca.ko $(MODULE_INSTALLDIR)
-	/sbin/depmod -ae
 
 uninstall:
 	rm -f $(MODULE_INSTALLDIR)gspca.ko
-	/sbin/depmod -aq
 
 endif
 


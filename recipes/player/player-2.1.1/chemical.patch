--- a/acinclude.m4	2008-04-16 04:40:20.000000000 +0200
+++ b/acinclude.m4	2009-01-06 12:54:20.000000000 +0100
@@ -211,6 +211,8 @@
 
 PLAYER_ADD_DRIVER([cmvision],[yes],[],[],[])
 
+PLAYER_ADD_DRIVER([chemical],[yes],[],[],[])
+
 PLAYER_ADD_DRIVER([create],[yes],[],[],[])
 
 PLAYER_ADD_DRIVER([dummy],[yes],[],[],[])
--- a/configure.ac	2008-06-16 01:38:40.000000000 +0200
+++ b/configure.ac	2009-01-06 12:54:20.000000000 +0100
@@ -575,6 +575,7 @@
           server/drivers/camera/sphere/Makefile
           server/drivers/camera/uvc/Makefile
           server/drivers/camera/yarp/Makefile
+           server/drivers/chemical/Makefile
           server/drivers/fiducial/Makefile
           server/drivers/ptz/Makefile
           server/drivers/laser/Makefile
--- a/client_libs/libplayerc/dev_chemical.c	1970-01-01 01:00:00.000000000 +0100
+++ b/client_libs/libplayerc/dev_chemical.c	2009-01-06 13:32:01.000000000 +0100
@@ -0,0 +1,111 @@
+/*
+ *  libplayerc : a Player client library
+ *  Copyright (C) Andrew Howard 2002-2003
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+/*
+ *  Player - One Hell of a Robot Server
+ *  Copyright (C) Andrew Howard 2003
+ *
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/***************************************************************************
+ * Desc: Chemical sensor proxy.
+ * Author: Elvina Motard
+ * Date: 5 January 2009
+ * CVS: $Id: dev_chemical.c 6566 2008-06-14 01:00:19Z thjc $
+ **************************************************************************/
+#if HAVE_CONFIG_H
+  #include "config.h"
+#endif
+
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netinet/in.h>
+
+#include "playerc.h"
+#include "error.h"
+
+// Local declarations
+void playerc_chemical_putmsg(playerc_chemical_t *device,
+                           player_msghdr_t *header,
+                           player_chemical_data_t *data,
+                           size_t len);
+
+// Create a new chemical sensor proxy
+playerc_chemical_t *playerc_chemical_create(playerc_client_t *client, int index)
+{
+  playerc_chemical_t *device;
+
+  device = malloc(sizeof(playerc_chemical_t));
+  memset(device, 0, sizeof(playerc_chemical_t));
+  playerc_device_init(&device->info, client, PLAYER_CHEMICAL_CODE, index,
+                      (playerc_putmsg_fn_t) playerc_chemical_putmsg);
+  return device;
+}
+
+
+// Destroy a chemical sensor proxy
+void playerc_chemical_destroy(playerc_chemical_t *device)
+{
+  playerc_device_term(&device->info);
+  free(device);
+}
+
+
+// Subscribe to the chemical sensor device
+int playerc_chemical_subscribe(playerc_chemical_t *device, int access)
+{
+  return playerc_device_subscribe(&device->info, access);
+}
+
+
+// Un-subscribe from the chemical sensor device
+int playerc_chemical_unsubscribe(playerc_chemical_t *device)
+{
+  return playerc_device_unsubscribe(&device->info);
+}
+
+
+// Process incoming data
+void playerc_chemical_putmsg(playerc_chemical_t *device, player_msghdr_t *header, player_chemical_data_t *data, size_t len)
+{
+  if((header->type == PLAYER_MSGTYPE_DATA) &&
+     (header->subtype == PLAYER_CHEMICAL_DATA_STATE))
+  {
+    device->chemical_id        = data->chemical_id;
+    device->concentration      = data->concentration;
+    device->temperature        = data->temperature;
+  }
+    return;
+}
+
+
--- a/client_libs/libplayerc/Makefile.am	2008-04-13 00:16:35.000000000 +0200
+++ b/client_libs/libplayerc/Makefile.am	2009-01-06 13:32:01.000000000 +0100
@@ -31,6 +31,7 @@
                         dev_bumper.c \
                         dev_blobfinder.c \
                         dev_camera.c \
+                        dev_chemical.c \
                         dev_dio.c \
                         dev_fiducial.c \
                         dev_gps.c \
--- a/client_libs/libplayerc/playerc.h	2008-06-11 03:11:18.000000000 +0200
+++ b/client_libs/libplayerc/playerc.h	2009-01-06 13:32:01.000000000 +0100
@@ -1418,6 +1421,51 @@
 /**************************************************************************/
 
 
+/***************************************************************************/
+/** @ingroup playerc_proxies
+ * @defgroup playerc_proxy_chemical chemical
+
+The chemical proxy can be used to get images from a chemical sensor.
+
+@{
+*/
+
+/** @brief chemical proxy data. */
+typedef struct
+{
+  /** Device info; must be at the start of all device structures. */
+  playerc_device_t info;
+
+  /** The Id of the chemical. */
+  int chemical_id;
+
+  /** The concentration of the chemical [0;99.9] (%). */
+  float concentration;
+
+  /** The temperature [0;99.9] (oC). */
+  float temperature;
+
+} playerc_chemical_t;
+
+
+/** @brief Create a chemical sensor proxy. */
+playerc_chemical_t *playerc_chemical_create(playerc_client_t *client, int index);
+
+/** @brief Destroy a chemical sensor proxy. */
+void playerc_chemical_destroy(playerc_chemical_t *device);
+
+/** @brief Subscribe to the chemical sensor device. */
+int playerc_chemical_subscribe(playerc_chemical_t *device, int access);
+
+/** @brief Un-subscribe from the chemical sensor device. */
+int playerc_chemical_unsubscribe(playerc_chemical_t *device);
+
+
+/** @} */
+/**************************************************************************/
+
+
+
 /**************************************************************************/
 /** @ingroup playerc_proxies
  * @defgroup playerc_proxy_dio dio
--- a/client_libs/libplayerc++/chemicalproxy.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/client_libs/libplayerc++/chemicalproxy.cc	2009-01-06 13:32:01.000000000 +0100
@@ -0,0 +1,102 @@
+/*
+ *  Player - One Hell of a Robot Server
+ *  Copyright (C) 2000-2003
+ *     Brian Gerkey, Kasper Stoy, Richard Vaughan, & Andrew Howard
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+/********************************************************************
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ********************************************************************/
+
+/*
+ * $Id: chemicalproxy.cc 4227 2007-10-24 22:32:04Z thjc $
+ */
+
+#if HAVE_CONFIG_H
+  #include "config.h"
+#endif
+
+#include <cassert>
+#include <sstream>
+#include <iomanip>
+
+#include "playerc++.h"
+#include "debug.h"
+
+using namespace PlayerCc;
+
+ChemicalProxy::ChemicalProxy(PlayerClient *aPc, uint32_t aIndex)
+  : ClientProxy(aPc, aIndex),
+  mDevice(NULL)
+{
+  Subscribe(aIndex);
+  mInfo = &(mDevice->info);
+}
+
+ChemicalProxy::~ChemicalProxy()
+{
+  Unsubscribe();
+}
+
+void
+ChemicalProxy::Subscribe(uint32_t aIndex)
+{
+  scoped_lock_t lock(mPc->mMutex);
+  mDevice = playerc_chemical_create(mClient, aIndex);
+  if (NULL==mDevice)
+    throw PlayerError("ChemicalProxy::ChemicalProxy()", "could not create");
+
+  if (0 != playerc_chemical_subscribe(mDevice, PLAYER_OPEN_MODE))
+    throw PlayerError("ChemicalProxy::ChemicalProxy()", "could not subscribe");
+}
+
+void
+ChemicalProxy::Unsubscribe()
+{
+  assert(NULL!=mDevice);
+  scoped_lock_t lock(mPc->mMutex);
+  playerc_chemical_unsubscribe(mDevice);
+  playerc_chemical_destroy(mDevice);
+  mDevice = NULL;
+}
+
+
+std::ostream&
+std::operator << (std::ostream &os, const PlayerCc::ChemicalProxy &c)
+{
+  /*os << "#Chemical Sensor (" << c.GetInterface() << ":" << c.GetIndex() << ")" << std::endl;
+  os << "id : " << c.GetId() << "\tconcentration : " << c.GetConcentration() << "\ttemperature" << c.GetTemperature << std::endl;
+*/
+  return os;
+}
+
+
--- a/client_libs/libplayerc++/Makefile.am	2008-04-13 00:16:42.000000000 +0200
+++ b/client_libs/libplayerc++/Makefile.am	2009-01-06 13:32:01.000000000 +0100
@@ -36,6 +36,7 @@
                               blobfinderproxy.cc \
                               bumperproxy.cc \
                               cameraproxy.cc \
+                              chemicalproxy.cc \
                               dioproxy.cc \
                               fiducialproxy.cc \
                               gpsproxy.cc \
--- a//client_libs/libplayerc++/playerc++.h	2008-05-14 01:07:55.000000000 +0200
+++ b/client_libs/libplayerc++/playerc++.h	2009-01-06 13:32:01.000000000 +0100
@@ -569,6 +569,39 @@
 
 
 /**
+The @p ChemicalProxy class can be used to get data from a @ref
+interface_chemical device. */
+class ChemicalProxy : public ClientProxy
+{
+
+  private:
+
+    virtual void Subscribe(uint32_t aIndex);
+    virtual void Unsubscribe();
+
+    // libplayerc data structure
+    playerc_chemical_t *mDevice;
+
+  public:
+
+    /// Constructor
+    ChemicalProxy (PlayerClient *aPc, uint32_t aIndex=0);
+
+    virtual ~ChemicalProxy();
+
+    /// Id of the chemical
+	uint16_t GetId() const { return GetVar(mDevice->chemical_id); };
+
+	/// concentration of the chemical
+	float GetConcentration() const { return GetVar(mDevice->concentration); };
+
+	/// temperature
+	float GetTemperature() const { return GetVar(mDevice->temperature); };
+
+};
+
+
+/**
 The @p DioProxy class is used to read from a @ref interface_dio
 (digital I/O) device.
 */
@@ -2553,6 +2586,7 @@
   std::ostream& operator << (std::ostream& os, const PlayerCc::BlobfinderProxy& c);
   std::ostream& operator << (std::ostream& os, const PlayerCc::BumperProxy& c);
   std::ostream& operator << (std::ostream& os, const PlayerCc::CameraProxy& c);
+   std::ostream& operator << (std::ostream& os, const PlayerCc::ChemicalProxy& c);
   std::ostream& operator << (std::ostream& os, const PlayerCc::DioProxy& c);
   std::ostream& operator << (std::ostream& os, const PlayerCc::FiducialProxy& c);
   std::ostream& operator << (std::ostream& os, const PlayerCc::GpsProxy& c);
--- a/client_libs/libplayerc++/test/Makefile.am	2008-04-13 00:16:39.000000000 +0200
+++ b/client_libs/libplayerc++/test/Makefile.am	2009-01-06 13:32:01.000000000 +0100
@@ -42,7 +42,8 @@
                test_actarray.cc \
                test_aio.cc \
                test_speech.cc \
-               test_ranger.cc
+               test_ranger.cc \
+               test_chemical.cc
 
 
 
--- a/client_libs/libplayerc++/test/test.cc	2008-04-13 00:16:39.000000000 +0200
+++ b/client_libs/libplayerc++/test/test.cc	2009-01-06 13:32:01.000000000 +0100
@@ -69,6 +69,7 @@
         "  aio\n"\
         "  speech\n"\
         "  ranger\n"\
+        "  chemical\n"\
         "  position2d-subscribe  (subscribe to position2d indefinitely)\n"\
         "  gripper-subscribe     (subscribe to gripper indefinitely)\n"\
         "");
@@ -239,6 +240,8 @@
       if(strcmp(device, "ranger") == 0 || strcmp(device, "all") == 0)
         test_ranger(&client, index);
 
+      if(strcmp(device, "chemical") == 0 || strcmp(device, "all") == 0)
+        test_chemical(&client, index);
 
     } catch(std::exception& e) {
       FAIL();
--- a/client_libs/libplayerc++/test/test_chemical.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/client_libs/libplayerc++/test/test_chemical.cc	2009-01-06 13:32:01.000000000 +0100
@@ -0,0 +1,34 @@
+/*
+ * $Id: test_chemical.cc 2009-01-05 motard $
+ *
+ * a test for the C++ ChemicalSensorProxy
+ */
+
+#include "test.h"
+
+int test_chemical(PlayerClient *client, int index)
+{
+  TEST("chemical sensor");
+  try
+  {
+    using namespace PlayerCc;
+
+    ChemicalProxy cp(client, index);
+
+    for (int i=0; i<10; ++i)
+    {
+      TEST("read chemical");
+      client->Read();
+      PASS();
+
+      std::cout << cp << std::endl;
+
+    }
+  }
+  catch (PlayerCc::PlayerError e)
+  {
+    std::cerr << e << std::endl;
+    return -1;
+  }
+  return 1;
+}
--- a/client_libs/libplayerc++/test/test.h	2008-04-13 00:16:39.000000000 +0200
+++ b/client_libs/libplayerc++/test/test.h	2009-01-06 13:32:01.000000000 +0100
@@ -64,6 +64,7 @@
 int test_actarray(PlayerClient* client, int index);
 int test_aio(PlayerClient* client, int index);
 int test_ranger(PlayerClient* client, int index);
+int test_chemical(PlayerClient* client, int index);
 
 //int test_bps(PlayerClient* client, int index);
 
--- a/libplayercore/interfaces/065_chemical.def	1970-01-01 01:00:00.000000000 +0100
+++ b/libplayercore/interfaces/065_chemical.def	2009-01-06 13:32:01.000000000 +0100
@@ -0,0 +1,25 @@
+description {
+ * @brief chemical
+
+The @p chemical interface provides access to a chemical sensor providing a set of id, concentration and temperature.
+}
+
+/** Data subtype:   */
+message { DATA, STATE, 1, player_chemical_data_t };
+
+
+/** @brief Data: scan (@ref PLAYER_CHEMICAL_DATA_STATE)
+
+The @p chemical interface returns a chemical ID, a concentration and a temperature. */
+typedef struct player_chemical_data
+{
+  /** The Id of the chemical. */
+  uint16_t chemical_id;
+  /** The concentration of the chemical [0;99.9] (%) */
+  float concentration;
+  /** The temperature [0;99.9] (oC) */
+  float temperature;
+} player_chemical_data_t;
+
+
+/** @} */
--- a/server/drivers/Makefile.am	2008-04-13 00:16:22.000000000 +0200
+++ b/server/drivers/Makefile.am	2009-01-05 16:22:57.000000000 +0100
@@ -1,30 +1,31 @@
-SUBDIRS = \
-actarray \
-base \
-audio \
-blobfinder \
-camera \
-fiducial \
-gps \
-health \
-joystick \
-laser \
-opaque \
-localization \
-map \
-mcom \
-mixed \
-planner \
-position \
-ptz \
-service_adv \
-shell \
-speech \
-wifi \
-rfid \
-wsn \
-imu \
-pointcloud3d \
-ranger \
-vectormap \
-blackboard 
+SUBDIRS = \
+actarray \
+base \
+audio \
+blobfinder \
+camera \
+chemical \
+fiducial \
+gps \
+health \
+joystick \
+laser \
+opaque \
+localization \
+map \
+mcom \
+mixed \
+planner \
+position \
+ptz \
+service_adv \
+shell \
+speech \
+wifi \
+rfid \
+wsn \
+imu \
+pointcloud3d \
+ranger \
+vectormap \
+blackboard 
--- a/server/drivers/chemical/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ b/server/drivers/chemical/Makefile.am	2009-01-05 16:35:45.000000000 +0100
@@ -0,0 +1,8 @@
+noinst_LTLIBRARIES = 
+if INCLUDE_CHEMICAL
+noinst_LTLIBRARIES += libchemical.la
+endif
+
+AM_CPPFLAGS = -Wall -I$(top_srcdir)
+
+libchemical_la_SOURCES = chemical.cc
--- a/server/drivers/chemical/chemical.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/server/drivers/chemical/chemical.cc	2009-01-06 13:32:00.000000000 +0100
@@ -0,0 +1,260 @@
+/*
+ *  Player - One Hell of a Robot Server
+ *  Copyright (C) 2000
+ *     Brian Gerkey, Kasper Stoy, Richard Vaughan, & Andrew Howard
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+/*
+ Desc: Driver for the SHU chemical sensor
+ Author: 
+ Date: 8 Dec 2008
+*/
+
+/** @ingroup drivers Drivers */
+/** @{ */
+/** @defgroup driver_chemical chemical
+ * @brief SHU chemical sensor
+
+*/
+/** @} */
+
+
+#include <assert.h>
+#include <math.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <termios.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+
+#include <libplayercore/playercore.h>
+#include <libplayerxdr/playerxdr.h>
+
+class Chemical : public Driver
+{
+  public:
+
+    // Constructor
+    Chemical(ConfigFile* cf, int section);
+
+    int Setup();
+    int Shutdown();
+
+    // MessageHandler
+    int ProcessMessage(QueuePointer & resp_queue,
+		       player_msghdr * hdr,
+		       void * data);
+  private:
+    // serial port file handle
+    int file;
+
+    // string name of serial port to use
+    const char *port;
+
+    // serial port baudrate
+    int baudrate;
+
+    // Main function for device thread.
+    virtual void Main();
+
+    // Read range data from laser and fill the player_chemical_data_t structure
+    int ReadSensorData();
+
+  protected:
+
+    player_chemical_data_t data;
+};
+
+
+Driver* Chemical_Init(ConfigFile* cf, int section)
+{
+ 	return (Driver*)(new Chemical(cf,section));
+}
+
+
+
+void Chemical_Register(DriverTable* table)
+{
+ 	table->AddDriver("chemical", Chemical_Init);
+}
+
+
+
+////////////////////////////////////////////////////////////////////////////////
+// Constructor
+Chemical::Chemical(ConfigFile* cf, int section)
+    : Driver(cf, section, true, PLAYER_MSGQUEUE_DEFAULT_MAXLEN, PLAYER_CHEMICAL_CODE)
+{
+
+  this->port = cf->ReadString(section, "port", "/dev/ttyUSB0");
+
+  switch(cf->ReadInt(section, "baudrate", 9600))
+  {
+    case 9600:
+      this->baudrate = B9600;
+      break;
+
+    case 19200:
+      this->baudrate = 19200;
+      break;
+
+    case 38400:
+      this->baudrate = B38400;
+      break;
+
+    case 57600:
+      this->baudrate = B57600;
+      break;
+
+    case 115200:
+      this->baudrate = B115200;
+      break;
+
+#ifdef B230400
+    case 230400:
+      this->baudrate = B230400;
+      break;
+#endif
+
+    default:
+      this->baudrate = B9600;
+      break;
+  }
+
+  return;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Set up the device
+int Chemical::Setup()
+{
+  struct termios term;
+
+  PLAYER_MSG0(2, "Chemical sensor initialising");
+
+  // setup communication
+  this->file = open(this->port, O_RDWR | O_NOCTTY);
+
+  if (this->file < 0)
+  {
+    PLAYER_ERROR1("Unable to open serial port %s", this->port);
+    return -1;
+  }
+
+  tcgetattr(this->file, &term);
+
+  cfsetispeed(&term, baudrate);
+  cfsetospeed(&term, baudrate);
+
+  term.c_cflag |= (CLOCAL | CREAD);
+  term.c_cflag &= ~(CSIZE|PARENB);
+  term.c_cflag |= CS8;
+  term.c_cflag &= ~CRTSCTS;
+  term.c_lflag &= ~(ECHO|ECHONL|ISIG|IEXTEN);
+  term.c_lflag |= ICANON;
+  term.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);
+  term.c_oflag &= ~OPOST;
+
+  tcflush(this->file, TCIFLUSH);
+
+  tcsetattr(this->file, TCSANOW, &term);
+
+  PLAYER_MSG0(2, "chemical sensor ready");
+
+  // Start the device thread
+  StartThread();
+
+  return 0;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// Shutdown the device
+int Chemical::Shutdown()
+{
+  // shutdown chemical sensor device
+  StopThread();
+
+  close(this->file);
+
+  PLAYER_MSG0(2, "chemical sensor shutdown");
+
+  return(0);
+}
+
+
+int Chemical::ProcessMessage(QueuePointer & resp_queue,
+                           player_msghdr * hdr,
+                           void * data)
+{
+ // We don't have any message to proccess, do we ?
+
+  // Don't know how to handle this message.
+  return(-1);
+}
+////////////////////////////////////////////////////////////////////////////////
+// Main function for device thread
+void Chemical::Main()
+{
+
+  while(true)
+  {
+    // test if we are supposed to cancel
+    pthread_testcancel();
+
+    ProcessMessages();
+
+    // Process incoming data
+    if (!ReadSensorData())
+    {
+      // Make data available
+      this->Publish(this->device_addr,
+                    PLAYER_MSGTYPE_DATA, PLAYER_CHEMICAL_DATA_STATE,
+                    (void*)&this->data, 0);
+    }
+  }
+}
+
+
+int Chemical::ReadSensorData()
+{
+  int n;
+  char tmp[13];
+  tmp[12] = '\0';
+
+  n = read(this->file, tmp, 12);
+
+  if (n != 12 && tmp[3] != ',' && tmp[7] != ',' && tmp[11] != '\n')
+    return -1;
+
+  tmp[3] = '\0';
+  this->data.chemical_id = atoi(&tmp[0]);
+
+  tmp[7] = '\0';
+  this->data.concentration = (float) atoi(&tmp[4]) / 10;
+
+  tmp[11] = '\0';
+  this->data.temperature = (float) atoi(&tmp[8]) / 10;
+
+  return 0;
+}
--- a/server/libplayerdrivers/driverregistry.cc	2008-04-16 04:40:20.000000000 +0200
+++ b/server/libplayerdrivers/driverregistry.cc	2009-01-06 12:54:19.000000000 +0100
@@ -414,6 +413,10 @@
 void CameraUVC_Register(DriverTable *table);
 #endif
 
+#ifdef INCLUDE_CHEMICAL
+void Chemical_Register(DriverTable *table);
+#endif
+
 #ifdef INCLUDE_SPHERE
 void SphereDriver_Register(DriverTable *table);
 #endif
@@ -883,6 +886,10 @@
   CameraUVC_Register(driverTable);
 #endif
 
+#ifdef INCLUDE_CHEMICAL
+  Chemical_Register(driverTable);
+#endif
+
 #ifdef INCLUDE_SPHERE
   SphereDriver_Register(driverTable);
 #endif
